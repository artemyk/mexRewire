#include "mex.h"
// #include <cmath>
#include <omp.h>
#include <Accelerate/Accelerate.h>

#define NUMARGS 3
#define NUMOUT 1

// This is the declaration of the function... nothing here should really be changed
// nlhs is the Number of variables on the Left Hand Side of the equals sign from Matlab
// nlhs is the Number of variables on the Right Hand Side of the equals sign from Matlab
// plhs is the array of outputs (each one needs to be created and assigned here)
// prhs is the array of inputs
void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]) {
    // Check for proper number of arguments
    if (nrhs != NUMARGS) mexErrMsgTxt("Incorrect number of input arguments required.");
    else if (nlhs > NUMOUT) mexErrMsgTxt("Too many output arguments expected.");
   
    // Check data type of input argument. 
    if (!(mxIsSingle(prhs[0]))) mexErrMsgTxt("Input array must be of type single.");
    if (!(mxIsSingle(prhs[1]))) mexErrMsgTxt("Input array must be of type single.");
   
    const mwSize *dim_array;  
    dim_array = mxGetDimensions(prhs[0]);
    int num_samples= dim_array[0];
    int num_chs    = dim_array[1];
    int num_trials = dim_array[2];
    float f_num_samples(num_samples);

    float * leftData  = (float *) mxGetData(prhs[0]);
    float * rightData = (float *) mxGetData(prhs[1]);
    float * windowFunction = (float *) mxGetData(prhs[2]);

    unsigned windowSize = mxGetNumberOfElements(prhs[2]);
    bool doWindowing = false;
    if (windowSize > 0) {
      if (windowSize != num_samples) { mexErrMsgTxt("Window size must be same as # of samples"); }
      if (!(mxIsSingle(prhs[2])))    { mexErrMsgTxt("Window must be of type single.");           }
      doWindowing = true;
    }
    mwSize * out_dims = (mwSize *) mxMalloc (3 * sizeof(mwSize));
    out_dims[0] = num_trials;
    out_dims[1] = num_chs;
    out_dims[2] = num_chs;

    plhs[0] = mxCreateNumericArray(3, out_dims, mxSINGLE_CLASS, mxCOMPLEX);
    int mx1=mxGetNumberOfElements(plhs[0]);
  
    float * outData     = (float *) mxGetData(plhs[0]);
    float * outDataImag = (float *) mxGetImagData(plhs[0]);
    
    #pragma omp parallel for 
    // shared(leftData, rightData, outData, outDataImag) 
    for (unsigned cTrial = 0; cTrial < num_trials; cTrial++) {
        float diff[num_samples], diffCos[num_samples], diffSin[num_samples]; 
        for (unsigned ch1 = 0; ch1 < num_chs ; ch1++) {
            for (unsigned ch2 = 0; ch2 < num_chs ; ch2++) {
                // subtract vectors: leftData - rightData 
                vDSP_vsub(&rightData[num_samples * (ch2 + cTrial*num_chs)], stride, &leftData[num_samples * (ch1 + cTrial*num_chs)], stride, diff, 1, num_samples);
                // get sines and cosines of difference
                vvsincosf(diffSin, diffCos, diff, &num_samples);
                
                // if window passed in, then
                if (doWindowing) {
                 vDSP_vmul(windowFunction, 1, diffSin, 1, diffSin, 1, num_samples);  
                 vDSP_vmul(windowFunction, 1, diffCos, 1, diffCos, 1, num_samples); 
                }
                // sum them up, gcc should auto-vectorize this
                float phaseDiffReal = 0; for (int i = 0; i < num_samples; i++) phaseDiffReal += diffCos[i]; 
                float phaseDiffImag = 0; for (int i = 0; i < num_samples; i++) phaseDiffImag += diffSin[i]; 
                unsigned  long outNdx = cTrial + ch1 * num_trials + ch2 * num_trials * num_chs;
                outData[     outNdx ] = phaseDiffReal/f_num_samples;
                outDataImag[ outNdx ] = phaseDiffImag/f_num_samples;
            }
        }
    }
}
